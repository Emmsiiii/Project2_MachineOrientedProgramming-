Index: deck.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Emma Rebner on 03/04/2024.\n//\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h> // include for malloc\n\n\n// Subtask 1.1: Define Card Struct\nstruct Card {\n    char rank[10];       // Enough space for '10' plus a null terminator\n    char suit;          // Suit of the card (e.g., 'H' for hearts, 'S' for spades)\n    bool isVisible;     // Visibility of the card (0 for face down, 1 for face up)\n};\n\n// Subtask 1.2: Define Node Struct\ntypedef struct Node {\n    struct Card card;          // Card held by the node\n    struct Node* next;  // Pointer to the next node\n} Node;\n\n// Subtask 1.3: Define List Struct\ntypedef struct {\n    Node* head;         // Pointer to the head node of the list\n    int size;           // Size of the list (optional)\n} List;\n\n// Subtask 2.1: Create and Destroy\nList* createList() {\n    List* newList = (List*)malloc(sizeof(List));\n    if (newList != NULL) {\n        newList->head = NULL;\n        newList->size = 0;\n    }\n    return newList;\n}\n\nNode* createNode(struct Card card) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    if (newNode != NULL) {\n        newNode->card = card;\n        newNode->next = NULL;\n    }\n    return newNode;\n}\n\nvoid destroyList(List* list) {\n    if (list != NULL) {\n        Node* current = list->head;\n        while (current != NULL) {\n            Node* next = current->next;\n            free(current);\n            current = next;\n        }\n        free(list);\n    }\n}\n\n// Subtask 2.2: Insertion and Deletion\nvoid insertAtHead(List* list, struct Card card) {\n    Node* newNode = createNode(card);\n    if (newNode != NULL) {\n        newNode->next = list->head;\n        list->head = newNode;\n        list->size++;\n    }\n}\n\nvoid insertAtTail(List* list, struct Card card) {\n    Node* newNode = createNode(card);\n    if (newNode != NULL) {\n        if (list->head == NULL) {\n            list->head = newNode;\n        } else {\n            Node* current = list->head;\n            while (current->next != NULL) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n        list->size++;\n    }\n}\n\nvoid removeNode(List* list, Node* nodeToRemove) {\n    if (list->head == NULL || nodeToRemove == NULL) {\n        return;\n    }\n\n    if (list->head == nodeToRemove) {\n        list->head = nodeToRemove->next;\n    } else {\n        Node* current = list->head;\n        while (current != NULL && current->next != nodeToRemove) {\n            current = current->next;\n        }\n        if (current != NULL) {\n            current->next = nodeToRemove->next;\n        }\n    }\n    free(nodeToRemove);\n    list->size--;\n}\n\n// Subtask 2.3: Searching and Traversal\nvoid printList(List* list) {\n    Node* current = list->head;\n    while (current != NULL) {\n        printf(\"%c%c \", current->card.rank, current->card.suit);\n        current = current->next;\n    }\n    printf(\"\\n\");\n}\n\nNode* findCard(List* list, struct Card cardToFind) {\n    Node* current = list->head;\n    while (current != NULL) {\n        // Use strcmp for string comparison and correct access to card fields\n        if (strcmp(current->card.rank, cardToFind.rank) == 0 && current->card.suit == cardToFind.suit) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// deck into 7 coloumns\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/deck.c b/deck.c
--- a/deck.c	
+++ b/deck.c	
@@ -126,7 +126,6 @@
     return NULL;
 }
 
-// deck into 7 coloumns
 
 
 
